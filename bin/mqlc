#!/bin/bash
#
# A script for compiling MQL4.0, MQL4.5 and MQL5 source files. Supports batch-processing of multiple
# files and directories. Prints results to STDOUT and follows standard rules for the exit status.
# The syntax is compatible with the syntax of MetaEditor.
#
# Configuration via environment or config file.
#
# @see  "/.env.dist"
# @see  https://www.metatrader5.com/en/metaeditor/help/beginning/integration_ide#compiler
#
#
# TODO:
#  - implement compareDirs()
#  - preconfigured versions per directory
#  - preconfigured include dirs per directory
#  - move config to standard location
#  - fix error when a specified directory doesn't contain sources
#  - improve error messages for filenames looking like options
#  - long help, short usage on syntax errors
#  - support Windows filenames/paths as arguments
#  - reformat compiler messages
#  - implement download tracker
#
#  - auto-detect version
#  - auto-detect include directory
#  - fix /portable issue without /include option
#
#  - add --no-rc option
#  - add bitness and sigdate to compiler infos
#  - normalize source names and filter duplicates
#  - colored output
#  - parallel compilation of multiple files
#
set -eEu -o pipefail


# --- functions ----------------------------------------------------------------------------------------------------------------------------


#
# Show the help screen.
#
function help() {
  cat << 'SYNTAX'
Compiles one or more MQL4.0, MQL4.5 and MQL5 source files or directories.

Usage: mqlc  [options] [--] SOURCE...
       mqlc  [options] /compile:(FILE|DIR)... [/include:DIR]... [/log[:FILE]]

Arguments:
  SOURCE           One or more source files or directories to compile. Supports wildcards.

Options:
  -h --help        This screen.
  /compile:FILE    Source file to compile. Doesn't support wildcards.
  /compile:DIR     Source directory to compile. Recompiles new and modified source files (not in subdirectories).
  /include:DIR     Include directory for all source files following the option (default: "<data-dir>/MQL4" or "<data-dir>/MQL5").
  /log             Writes all output to file "<source-file.log>" (default: no log on success, always log errors/warnings).
  /log:FILE        Writes all output to a custom log file.
  -v=VERSION       Explicit version of MQL4 source files following the option: either "mql40" or "mql45".
  -v= --version=   Empty version argument: auto-detects the version of MQL4 source files following the option (default).
  -s --syntax      Syntax check only, no compilation.
  -o --original    Preserves the original and unmodified compiler output, followed by the original exit status.
  -w --warn2error  Treats compiler warnings as errors, affects the exit status for warnings.

Auto-detection of MQL versions:
 ".mq5" files are always processed as MQL5, a specified version has no effect.
 ".mq4" files: If the base name of the MQL include directory resolves to "experts" or "mql40", version "mql40" is assumed.
 ".mq4" files: If the base name of the MQL include directory resolves to "mql4" or "mql45", version "mql45" is assumed.
 Default MQL versions for custom directories can be predefined in the configuration (see "/.env.dist").

Compilers may be specified via environment variables or predefined in the configuration (see "/.env.dist").

The script exits with 0 (success) or the number of errors of the last failing compilation.

SYNTAX
}


#
# Initialization.
#
function init() {
  trap onExit EXIT                                          # setup exit handler *first*
  registerTmpFile ""                                        # initialize management of tmp. files
}


_tmpFiles=''                                                # file holding the names of managed tmp. files
#
# Register a file path for automatic deletion on script termination.
#
# @param $1 - filename/path
#
function registerTmpFile() {
  if [[ -z "$_tmpFiles" ]]; then                            # initialization on first call
    _tmpFiles="$(mktemp --tmpdir "$(basename "$0").XXXXXX")"
    readonly _tmpFiles
    registerTmpFile "$_tmpFiles"                            # register the file itself as first entry
  fi

  # add new tmp file
  [[ -n "$1" ]] && echo "$1" >> "$_tmpFiles" || :
}


#
# Exit handler. Cleans-up temporary files before script termination.
#
function onExit() {
  local lines=() file i exists isDir
  mapfile -t lines < "$_tmpFiles"

  # delete paths in LIFO order to prevent orphans behind tmp. reparse points
  for ((i=${#lines[@]}-1; i >= 0; i--)); do
    file="${lines[i]}"
    [[ -e "$file" ]] && exists=1 || exists=0
    [[ -d "$file" ]] && isDir="(dir)" || isDir=
    rm -rf -- "$file"
    ((debug && exists)) && echo "onExit: rm $file $isDir" || :
  done
}


declare isConfig=0 isLogs=0 isMql4=0 isMql5=0

#
# Remember directories in a compiler directory. Used by cleanupCompilerDir() to cleanup.
#
# @param $1 - compiler filename
#
function checkCompilerDir() {
  local dir; dir="$(dirname "$(realpath "$1")")"

  [[ -d "$dir/config" ]] && isConfig=1 || isConfig=0
  [[ -d "$dir/logs"   ]] && isLogs=1   || isLogs=0
  [[ -d "$dir/mql4"   ]] && isMql4=1   || isMql4=0
  [[ -d "$dir/mql5"   ]] && isMql5=1   || isMql5=0
}


#
# Clean-up directories created by the MetaEditor compiler.
# (metalang.exe doesn't create any directories by itself)
#
# @param $1 - compiler filename
#
function cleanupCompilerDir() {
  local dir; dir="$(dirname "$(realpath "$1")")"

  ((!isConfig)) && [[ -d "$dir/config" ]] && rm -rf "$dir/config"
  ((!isLogs  )) && [[ -d "$dir/logs"   ]] && rm -rf "$dir/logs"
  ((!isMql4  )) && [[ -d "$dir/mql4"   ]] && rm -rf "$dir/mql4"
  ((!isMql5  )) && [[ -d "$dir/mql5"   ]] && rm -rf "$dir/mql5"

  return 0
}


#
# Creates a tmp. helper batch file and returns its full name. The name doesn't contain spaces
# and needs no quoting. On script termination the file is automatically removed.
#
function cmdHelper() {
  local helper; helper="$(mktemp --tmpdir --suffix=.bat "$(basename "$0").XXXXXX")"
  registerTmpFile "$helper"

  if [[ "$helper" =~ \  ]]; then
    helper="$(cygpath -d "$helper")"      # the DOS name prevents argument mangling of double quotes which would break the call
  else
    helper="$(cygpath -w "$helper")"
  fi
  echo "$helper"
}


#
# Test whether two logical directories are physically the same.
# Returns 1 if directories are the same, and 0 otherwise.
#
# @param $1 - first directory
# @param $2 - second directory
#
function compareDirs() {
  echo "0"
}


#
# Compile an MQL4.0 source file.
#
# @param $1 - filename
# @param $2 - MQL version id
# @param $3 - include directory
#
function compileMql40() {
  local srcFile="$1" version="$2" include="$3"
  local compiler errorStatus=0 startms endms time='' output=() line errors=0 epl='' warnings=0 wpl='' retVal
  compilerPath "$version" "$include"                                  # sets local compiler

  # call the compiler and measure execution time
  ((originalOutput)) || echo "Compiling \"$srcFile\" as $(versionName "$version")"
  ((debug)) && echo "cmd: $compiler $srcFile"
  startms="$(date +%s%3N)"
  mapfile -t output < <(
    { MSYS_NO_PATHCONV=1 "$compiler" "$srcFile" < /dev/null 2>&1 || errorStatus=$?; echo "$errorStatus"; } | tr -d '\r'
  )
  endms="$(date +%s%3N)"
  errorStatus="${output[-1]}"                                         # fetch error status from output and remove it
  unset 'output[-1]'

  # on success
  if ((!errorStatus)); then
    [[ "${output[-1]}" =~ ^(Exp|Library exp)\ file\ .+\ produced\ -\ ([0-9]+)\ error.+\ ([0-9]+)\ warning.+ ]] || {
      fail "ERROR: unexpected compiler output in last line: \"${output[-1]}\"";
    }
    errors="${BASH_REMATCH[2]}";   ((errors   == 1)) && epl='' || epl='s'
    warnings="${BASH_REMATCH[3]}"; ((warnings == 1)) && wpl='' || wpl='s'

    if ((!originalOutput)); then
      time="$(duration "$startms" "$endms")"
      output[-1]="Result: $errors error$epl, $warnings warning$wpl, $time elapsed"
      ((!warnings))              && output+=('Success')
      ((warnings && warn2error)) && output+=('Error')
    fi
  fi

  # on error
  if ((errorStatus)); then
    if [[ ${#output[@]} -lt 4 ]]; then                                # no error message happens for empty source file only
      ((errorStatus != 127)) && fail "ERROR: unexpected compiler output for status $errorStatus: no error message"
      ((originalOutput)) || output+=("2;356;$srcFile;1:1;'' - event handling function not found")
      ((errors++)) || :
    else
      # count errors and warnings
      local i
      for ((i=3; i < ${#output[@]}; i++)); do
        [[ "${output[i]}" != [0-9]* ]] && break
        [[ "${output[i]}" == [1]* ]] && { ((warnings++)) || :; continue; }
        [[ "${output[i]}" == [2]* ]] && { ((errors++))   || :; continue; }
        fail "ERROR: unknown message type in: ${output[i]}"
      done
    fi

    if ((!originalOutput)); then
      [[ "${output[-1]}" =~ ^[[:space:]]*$ ]] && unset 'output[-1]'   # remove an empty last line
      [[ "${output[-1]}" == See\ logfile*  ]] && unset 'output[-1]'   # remove a logfile hint
      [[ "${output[-1]}" == Errors--[0-9]* ]] && unset 'output[-1]'   # remove an error counter
      [[ "${output[-1]}" =~ ^[[:space:]]*$ ]] && unset 'output[-1]'   # remove another empty last line

      # add final results
      ((errors   == 1)) && epl='' || epl='s'
      ((warnings == 1)) && wpl='' || wpl='s'
      time="$(duration "$startms" "$endms")"
      output+=("Result: $errors error$epl, $warnings warning$wpl, $time elapsed")
      output+=("Error")
    fi
  fi

  if ((originalOutput)); then
    output+=("$errorStatus")
  else
    output[0]="${output[0]//compiler build/compiler version 4.00 build}"              # update compiler version
    [[ "${output[1]}" =~ ^Copyright ]] && unset 'output[1]'                           # remove copyright
    ((compactOutput)) && [[ "${output[2]}" =~ ^[[:space:]]*$ ]] && unset 'output[2]'  # more compact output
  fi

  # print everything to STDOUT
  for line in "${output[@]}"; do
    echo "$line"
  done

  ((warn2error)) || warnings=0
  ((retVal = errors + warnings))
  ((retVal > 255)) && retVal=255
  return "$retVal"
}


#
# Compile an MQL4.5/MQL5 source file.
#
# @param $1 - filename
# @param $2 - MQL version id
# @param $3 - include directory to use
#
function compileMql5() {
  local srcFile="$1" logFile="${1%.*}.log" version="$2" include="$3"
  local helper compiler compilerCmd includeOption='' errorStatus=0
  compilerPath "$version"                                             # sets local compiler

  if ((!originalOutput)); then
    echo "Compiling \"$srcFile\" as $(versionName "$version")"
    compilerInfo "$compiler"
    ((compactOutput)) || echo ""
  fi

  compiler="$(cygpath -w "$compiler")"
  [[ -n "$include" ]] && includeOption="/include:\"$include\""
  compilerCmd="\"$compiler\" /compile:\"$srcFile\" $includeOption /log:\"$logFile\""
  ((debug)) && echo "cmd: $compilerCmd"

  helper="$(cmdHelper)"
  echo '@echo off'     > "$helper"
  echo "$compilerCmd" >> "$helper"

  # run the compiler
  checkCompilerDir "$compiler"
  rm -f -- "$logFile"
  MSYS_NO_PATHCONV=1 cmd /c "$helper" < /dev/null 2>&1 || errorStatus=$?
  [[ -f "$logFile" ]] || fail "ERROR: logfile \"$logFile\" not found (status $errorStatus)."
  rm -f "$helper"
  cleanupCompilerDir "$compiler"

  # store logfile in array (convert to UTF-8, Unix EOL, filter blank lines and infos)
  local output=() line='' M='' errors=0 warnings=0
  mapfile -t output < <(
    ((originalOutput)) && M="rosasurfer"                      # marker to toggle result filtering
    iconv -c -f UTF-16 -t UTF-8 "$logFile" | tr -d '\r' | grep -v -E "^${M}[[:space:]]*$|${M}: information: (compiling|including|generating code|code generated)" || :
  )

  [[ "${output[-1]}" =~ ([0-9]+)\ errors,\ ([0-9]+)\ warnings ]] || fail "ERROR: unexpected compiler output in last line: \"${output[-1]}\""
  errors="${BASH_REMATCH[1]}"
  warnings="${BASH_REMATCH[2]}"
  ((!errors && !warnings)) && rm -f "$logFile"

  if ((originalOutput)); then
    output+=("$errorStatus")
  else
    ((!errors && !warnings))               && output+=("Success")
    ((errors || (warn2error && warnings))) && output+=("Error")
  fi

  # print everything to STDOUT
  for line in "${output[@]}"; do
    echo "$line"
  done

  ((warn2error)) || warnings=0
  ((retVal = errors + warnings))
  ((retVal > 255)) && retVal=255
  return "$retVal"
}


#
# Return product and version infos for the passed compiler filename.
#
# @param $1 - filename
#
function compilerInfo() {
  local file output product version
  file="$(cygpath -d "$1")"                       # the DOS name spares us quoting which would get mangled which would break the call

  output="$(MSYS_NO_PATHCONV=1 powershell -NoProfile -NonInteractive -Command "\$v = (Get-Item $file).VersionInfo; \$v.ProductName + [char]9 + \$v.FileVersion" < /dev/null)"
  output="${output#$'\xEF\xBB\xBF'}"              # cut-off a BOM header if present
  output="${output%$'\r'}"                        # cut-off a Windows EOL if present

  IFS=$'\t' read -r product version <<< "$output"

  [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)$ ]] || {
    fail "ERROR: unexpected VersionInfo.FileVersion \"$version\" for \"$1\""
  }
  version="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}${BASH_REMATCH[3]} build ${BASH_REMATCH[4]}"

  echo "$product version $version"
}


declare -A _cachedCompilerPaths                   # cached results (requires BASH_SUBSHELL=0)
_cachedCompilerPaths=()

#
# Resolves the full compiler filename for the specified MQL version, and sets variable 'compiler' in the outer scope.
#
# @param $1 - MQL version id
# @param $2 - include directory, will be linked into the compiler path (MQL4.0 only)
#
function compilerPath() {
  ((BASH_SUBSHELL)) && fail "ERROR: ${FUNCNAME[0]}() can't modify outer scope from subshell"
  local compilerVar version="$1" includeDir="${2:-}"
  [[ "$version" != 'mql40' || "$includeDir" == 'auto' || "$includeDir" == '<auto>' ]] && includeDir=

  # check the cache for a matching result
  if [[ -n "${_cachedCompilerPaths["$version|$includeDir"]:-}" ]]; then
    compiler="${_cachedCompilerPaths["$version|$includeDir"]}"
    return
  fi

  [[ "$version" == 'mql40' ]] && compilerVar='MT4_METALANG'
  [[ "$version" == 'mql45' ]] && compilerVar='MT4_METAEDITOR'
  [[ "$version" == 'mql5'  ]] && compilerVar='MT5_METAEDITOR'

  [[ -z "${compilerVar:-}" ]] && fail "ERROR: unknown MQL version id \"$version\""
  [[ -z "${!compilerVar-}" ]] && fail "ERROR: $(versionName "$version") compiler is not configured"
  [[ -f "${!compilerVar}"  ]] || fail "ERROR: $(versionName "$version") compiler not found: \"${!compilerVar}\""
  compiler="${!compilerVar}"

  if [[ "$version" == 'mql40' && -n "$includeDir" ]]; then
    compiler="$(prepareCompiler40Dir "$compiler" "$includeDir")"
  fi

  # cache the result
  _cachedCompilerPaths["$version|$includeDir"]="$compiler"
}


#
# cygpath doesn't support the "--" option separator. If the passed name starts with "-" it breaks.
# This function works around that issue.
#
# @param $1 - cygpath conversion modifier
# @param $2 - filename/path
#
function cygpath() {
  local name="$2"
  [[ "$name" == -* ]] && name="./$name"
  command cygpath "$1" "$name"
}


#
# Caluclate the duration time of two timestamps and return a formatted result.
#
# @param $1 - start time in msec
# @param $2 - end time in msec
#
function duration() {
  local startms="$1" endms="$2" duration

  ((duration = endms-startms))

  if ((duration < 1000)); then
    echo "$duration msec"
  else
    printf '%d.%03d sec' $((duration / 1000)) $((duration % 1000))
  fi
}


#
# Prints a message to STDERR but doesn't exit the script/subshell.
#
# @param $@ - any number of arguments
#
function error() {
  echo "$@" 1>&2
}


#
# Prints a message to STDERR and exits the script/subshell.
#
# @param $@ - any number of arguments
#
function fail() {
  echo "$@" 1>&2
  exit 1
}


#
# Return the file extension of the passed name.
#
# @param $1 - filename
#
function fileExtension() {
  local ext="${1##*.}"
  [[ "$1" == "$ext" ]] && ext=
  echo "$ext"
}


#
# Prepare a compiler path for MQL4.0 and link the specified include directory into it.
# Return the prepared full compiler path
#
# @param $1 - compiler path
# @param $2 - include directory
#
function prepareCompiler40Dir() {
  local compiler="$1" includeDir="$2" includeDirW expertsDir expertsDirW tmpDir
  expertsDir="$(dirname "$compiler")/experts"

  # quick return if expertsDir already matches includeDir
  if [[ -d "$expertsDir" && "$(compareDirs "$expertsDir" "$includeDir")" == "1" ]]; then
    echo "$compiler"
    return
  fi

  # create tmp directory
  tmpDir="$(mktemp -d --tmpdir "$(basename "$0").XXXXXX")"
  registerTmpFile "$tmpDir"

  # copy compiler to tmp directory and link includeDir to experts
  cp "$compiler" "$tmpDir"
  expertsDirW="$(cygpath -wa "$tmpDir/experts")"
  includeDirW="$(cygpath -wa "$includeDir")"
  MSYS_NO_PATHCONV=1 cmd /c mklink /D "$expertsDirW" "$includeDirW" < /dev/null > /dev/null || fail "ERROR: mklink /D \"$expertsDirW\" \"$includeDirW\" failed with status $?"

  # return tmpDir/compiler
  compiler="$tmpDir/$(basename "$compiler")"
  echo "$compiler"
}


#
# Read the configuration into global vars.
#
function readConfig() {
  # backup existing env vars
  local BAK_MT4_METALANG="${MT4_METALANG:-}"
  local BAK_MT4_METAEDITOR="${MT4_METAEDITOR:-}"
  local BAK_MT5_METAEDITOR="${MT5_METAEDITOR:-}"

  # source an existing .env file
  local scriptDir; scriptDir="$(dirname "$(realpath "$0")")"
  local envFile="$scriptDir/../.env"
  [[ -f "$envFile" ]] && . "$envFile"

  # resolve final values: environment precedes config file
  MT4_METALANG="${BAK_MT4_METALANG:-${MT4_METALANG:-}}"
  MT4_METAEDITOR="${BAK_MT4_METAEDITOR:-${MT4_METAEDITOR:-}}"
  MT5_METAEDITOR="${BAK_MT5_METAEDITOR:-${MT5_METAEDITOR:-}}"

  # validate base names
  if [[ -n "$MT5_METAEDITOR" ]]; then
    basename="$(basename "$MT5_METAEDITOR")"
    [[ "${basename,,}" != "metaeditor64.exe" ]] && fail "ERROR: The base name of the MT5 MetaEditor must be: \"metaeditor64.exe\""
  fi
  readonly MT4_METALANG MT4_METAEDITOR MT5_METAEDITOR
}


#
# Resolve the MQL include directory for a source file, taking into account an explicit or configured value.
# If neither input nor configuration exist, the function tries to auto-detect the include directory.
#
# @param $1 - filename
# @param $2 - MQL version id
# @param $3 - input include dir
#
function resolveIncludeDir() {
  echo "$3"
}


#
# Resolve the MQL version of a source file, taking into account an explicit or configured value.
# If neither input nor configuration exist, the function tries to auto-detect the MQL version.
#
# @param $1 - filename
# @param $2 - input version
#
function resolveMqlVersion() {
  local ext; ext="$(fileExtension "$1")"
  [[ "${ext,,}" == "mq5" ]] && echo "mql5" || echo "$2"
}


#
# Sanitize a filename/path argument. Strips enclosing double quotes and trims white-space.
#
# @param $1 - name
#
function sanitizeName() {
  local str="$1"
  [[ "$str" =~ ^\"(.*)\"$ ]] && str="${BASH_REMATCH[1]}"    # strip enclosing double quotes

  str="${str#"${str%%[![:space:]]*}"}"                      # trim leading white space
  str="${str%"${str##*[![:space:]]}"}"                      # trim trailing white space

  echo "$str"
}


#
# Return the name of an MQL version.
#
# @param $1 - MQL version id
#
function versionName() {
  [[ "$1" == 'mql40' ]] && { echo 'MQL 4.0'; return; }
  [[ "$1" == 'mql45' ]] && { echo 'MQL 4.5'; return; }
  [[ "$1" == 'mql5'  ]] && { echo 'MQL 5';   return; }

  fail "ERROR: unknown MQL version id: \"$1\""
}


# --- end of functions ---------------------------------------------------------------------------------------------------------------------


# define vars
declare srcFileNames=() srcArg=''
declare srcFileVersions=() version='' firstVersion=-1
declare srcFileIncludes=() include='' firstInclude=-1
declare log=0 customLog='' syntaxOnly=0 originalOutput=0 compactOutput=0 warn2error=0 debug=0 delimiterPassed=0


# initialization
init


# parse command line arguments
((!"$#")) && { help; exit 0; }
while [[ "$#" -gt 0 ]]; do
  if ((!delimiterPassed)); then                           # enter case only before an option terminator
    case "$1" in
      --)
        delimiterPassed=1
        shift; continue;;

      --debug)
        debug=1
        shift; continue;;

      -h|--help)
        help; exit 0;;

      [-/]s|--syntax)                                     # also support MetaEditor's option prefix
        syntaxOnly=1
        shift; continue;;

      -o|--original)
        originalOutput=1
        shift; continue;;

      -w|--warn2error)
        warn2error=1
        shift; continue;;

      -v|--version)
        fail "ERROR: missing MQL4 version identifier: $1";;

      -v=*|--version=*)
        version="${1#*=}"
        version="${version,,}"
        [[ -n "$version" && "$version" != mql4[05] ]] && fail "ERROR: invalid MQL4 version identifier in \"$1\" (expecting \"mql40\" or \"mql45\")"
        if ((firstVersion < 0)); then
          for i in "${!srcFileVersions[@]}"; do
            srcFileVersions[i]="$version"                 # the first --version affects previous sources if no more sources follow
          done
          firstVersion="${#srcFileVersions[@]}"           # track position
        fi
        shift; continue;;

      /inc|/include|/inc[=:]*|/include[=:]*)
        [[ "$1" == /include* ]] && include="${1:9}" || include="${1:5}"
        include="$(sanitizeName "$include")"
        [[ -z "$include" ]] && fail "ERROR: missing argument: $1"
        [[ -d "$include" ]] || fail "ERROR: include directory not found: \"$include\""
        include="$(cygpath -w "$include")"
        if ((firstInclude < 0)); then
          for i in "${!srcFileIncludes[@]}"; do
            srcFileIncludes[i]="$include"                 # the first /include affects previous sources if no more sources follow
          done
          firstInclude="${#srcFileIncludes[@]}"           # track position
        fi
        shift; continue;;

      /log|/log[=:]*)
        [[ "$log" -eq 1 ]] && fail "ERROR: multiple /log options"
        log=1
        if [[ ${#1} -gt 4 ]]; then
          customLog="$(sanitizeName "${1:5}")"
          [[ -z "$customLog" ]] && fail "ERROR: missing argument: $1"
          customLog="$(cygpath -w "$customLog")"
        fi
        shift; continue;;

      /compile[=:]*)
        srcArg="$(sanitizeName "${1:9}")"
        [[ -z "$srcArg" ]] && fail "ERROR: missing argument: $1";;
        # processing continues after the case block
    esac
  fi

  # source files/directories before/after an argument delimiter, standalone or as /compile: argument
  ((delimiterPassed)) || [[ "$1" != /compile* ]] && srcArg="$1"

  if [[ -d "$srcArg" ]]; then
    while IFS= read -r file; do
      srcFileNames+=("$file")
      srcFileVersions+=("${version:-<auto>}")
      srcFileIncludes+=("${include:-<auto>}")
    done < <(find "$srcArg" -maxdepth 1 -type f -iname '*.mq[45]')
  elif [[ -f "$srcArg" ]]; then
    ext="$(fileExtension "$srcArg")"
    [[ "${ext,,}" != mq[45] ]] && fail "ERROR: cannot compile file \"$srcArg\""
    srcFileNames+=("$srcArg")
    srcFileVersions+=("${version:-<auto>}")
    srcFileIncludes+=("${include:-<auto>}")
  else
    srcArg="$1"
    [[ "$srcArg" =~ ^[[:space:]]*$ ]] && srcArg="\"$srcArg\""
    fail "ERROR: file or directory not found: $srcArg"
  fi

  if ((firstVersion > 0)); then
    for i in "${!srcFileVersions[@]}"; do
      ((i < firstVersion)) && srcFileVersions[i]="auto"   # the first --version affects previous sources only if no more sources follow
    done
    firstVersion=0                                        # position of the first implied version = start of arguments
  fi

  if ((firstInclude > 0)); then
    for i in "${!srcFileIncludes[@]}"; do
      ((i < firstInclude)) && srcFileIncludes[i]="auto"   # the first /include affects previous sources only if no more sources follow
    done
    firstInclude=0                                        # position of the first implied /include = start of arguments
  fi
  shift
done

((!${#srcFileNames[@]}))    && fail "ERROR: missing source file/directory argument"
((${#srcFileNames[@]} > 1)) && compactOutput=1

readonly srcFileNames
readonly srcFileVersions firstVersion
readonly srcFileIncludes firstInclude
readonly log customLog syntaxOnly originalOutput compactOutput warn2error debug
export debug


# read configuration
readConfig


# process each source file
exitCode=0

for i in "${!srcFileNames[@]}"; do
  ((i)) && echo ""

  file="${srcFileNames[i]}"
  version="$(resolveMqlVersion "$file" "${srcFileVersions[i]}")"
  include="$(resolveIncludeDir "$file" "$version" "${srcFileIncludes[i]}")"
  status=0

  case "$version" in
    mql40)
      compileMql40 "$file" "$version" "$include" || status=$?;;
    mql45|mql5)
      compileMql5  "$file" "$version" "$include" || status=$?;;
    *)
      fail "ERROR: cannot resolve MQL version of \"$file\"";;
  esac

  ((status)) && exitCode="$status"
done

exit "$exitCode"


notes << NOTES_METALANG

  metalang.exe's exit code is the number of encountered errors (0 = no errors but possibly warnings).

  success w/o warnings
  --------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe "Dow Jones Breakout.mq4"; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  Exp file "Dow Jones Breakout.ex4" produced - 0 error(s), 0 warning(s)
  0

  success with warnings
  ---------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe "Dow Jones Breakout.mq4"; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  1;33;C:\z\F\Projects\mt4\mql\bin\Dow Jones Breakout.mq4;149:8;'5' - comparison expression expected
  Exp file "Dow Jones Breakout.ex4" produced - 0 error(s), 1 warning(s)
  0

  syntax errors
  -------------
  $ MSYS_NO_PATHCONV=1 metalang.exe "Dow Jones Breakout.mq4"; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  2;124;C:\z\F\Projects\mt4\mql\bin\Dow Jones Breakout.mq4;146:12;'HandleCommand' - function is not defined
  1;33;C:\z\F\Projects\mt4\mql\bin\Dow Jones Breakout.mq4;149:8;'5' - comparison expression expected

  Errors--1
  See logfile "Dow Jones Breakout.log"

  1

  parser errors
  -------------
  $ MSYS_NO_PATHCONV=1 metalang.exe "Dow Jones Breakout.mq4"; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  2;89;C:\z\F\Projects\mt4\mql\bin\Dow Jones Breakout.mq4;526:1;'\end_of_program' - unbalanced left parenthesis
  1

  empty source file
  -----------------
  $ MSYS_NO_PATHCONV=1 metalang.exe empty.mq4; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.
  127

  regular text file as source
  ---------------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe output.txt; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  2;114;C:\z\F\Projects\mt4\mql\bin\output.txt;11:53;'some pewa text' - more than 1 symbol
  127

  binary source file
  ------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe metalang.exe; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  1;41;C:\z\F\Projects\mt4\mql\bin\metalang.exe;1:1;'MZ???' - expression on global scope not allowed
  2;75;C:\z\F\Projects\mt4\mql\bin\metalang.exe;1:1;'MZ???' - variable not defined
  1

  input file not found
  --------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe no-exist.mq4; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  2;76;;;cannot open the program file
  127

  access to output file denied
  ----------------------------
  $ MSYS_NO_PATHCONV=1 metalang.exe ChartInfos.mq4; echo $?
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  2;52;;;cannot open the output expert file
  1
NOTES_METALANG


notes << METAEDITOR_NOTES

  Git Bash's "cmd.exe" is the only syntax variant which doesn't mangle arguments. However, that syntax
  breaks Cygwin's POSIX launcher. So we go with "cmd" and manually demangle in the helper batch file.
  The helper file cannot just hold the final command as that doesn't support parallel executions.

  MetaEditor's exit code is the number of successfully processed files (0 = error). It doesn't produce
  any error messages.


  renamed executable
  ------------------
  $ MSYS_NO_PATHCONV=1 metaeditor64_.exe /compile:Exists.mq5 /log:custom.log; echo $?
  0 (no "custom.log", no "metaeditor.log")


  syntax errors without /log option
  ---------------------------------
  $ MSYS_NO_PATHCONV=1 metaeditor.exe /compile:Exists.mq4; echo $?
  0 (no "metaeditor.log")

  $ MSYS_NO_PATHCONV=1 metaeditor64.exe /compile:Exists.mq5; echo $?
  0 (summary in "metaeditor.log")


  input file not found
  --------------------
  $ MSYS_NO_PATHCONV=1 metaeditor*.exe /compile:DoesntExist.mq4 /log:custom.log; echo $?
  0 (no "custom.log", no "metaeditor.log")
METAEDITOR_NOTES


notes << OTHER_NOTES

  Syntax MQL4.5 + MQL5
  --------------------
  - compile single file
    $ metaeditor.exe /compile:<filename-without-spaces>
    $ metaeditor.exe /compile:"<filename with spaces>"

  - compile whole directory (recompiles only if a source file is newer than the compiled version, no subdirectories)
    $ metaeditor.exe /compile:"<target-directory>"

  - use custom include directory (default: "mql4/5" in directory containing metaeditor.exe)
    $ metaeditor.exe /include:"<separate-mql-directory>"                                                      # can be shortened to /inc:

  - create log file named <source-file.log>, without errors are logged to "<data-dir>/logs/metaeditor.log"
    $ metaeditor.exe /compile:"<source>" /log

  - create custom log file, not supported when compiling directories
    $ metaeditor.exe /compile:"<source>" /log:"<log-filename>"

  - check syntax only (no compilation)
    $ metaeditor.exe /compile:"<source>" /s


  MT4 after installation
  ----------------------
  metaeditor.exe /packed:21 /compile:"103304111_21238" /inc:"E:\Trading\MetaTrader\versions\1417\MQL4" /flg:2


  MT5 after installation
  ----------------------
  metaeditor64.exe /portable /compile:"E:\Trading\MetaTrader5\MQL5" /inc:"E:\Trading\MetaTrader5\MQL5" /time:1743564639 /flg:0 /stop:se5296_103760508


  metalang.exe -h
  ---------------
  MetaQuotes Language 4 compiler version 4.00 build 224 (14 May 2009)
  Copyright 2001-2009, MetaQuotes Software Corp.

  usage: metalang.exe [options] filename
  options:
  -q : quiet mode


  old multi-compiler (MT4 builds 600...615)
  -----------------------------------------
  mql.exe [<flags>] filename.mq5
          /mql5     - compile mql5 source
          /mql4     - compile mql4 source
          /s        - syntax check only
          /i:<path> - set working directory
          /o        - use code optimizer


  UltraEdit
  ---------
  bash /f/Projects/mt4/mql/bin/mqlc "%f" /include:/f/Projects/mt4/mql/mql40 -f=mql40
  bash /f/Projects/mt4/mql/bin/mqlc "%f" /include:/f/Projects/mt4/mql/mql45 -f=mql45
  bash /f/Projects/mt4/mql/bin/mqlc "%f" /include:/f/Projects/mt4/mql/mql5

  @see  https://stackoverflow.com/questions/356100/how-to-wait-in-bash-for-several-subprocesses-to-finish-and-return-exit-code-0

OTHER_NOTES
